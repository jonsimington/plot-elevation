from rasterio.merge import merge
from rasterio.plot import show
import glob
from osgeo import gdal
import matplotlib.pyplot as plt
import os
import elevation
import rasterio as rio
from rasterio.mask import mask
import geopandas as gpd

def merge_tiffs(base_output_path, merged_output_path):
    """
    Merges TIFF files in a specified directory into a single TIFF file.

    Parameters:
    - base_output_path: The base path used for the output files during download.
    - merged_output_path: The path for the merged output file.
    """
    # Find all TIFF files generated by the download process
    tiff_files = find_clipped_tiff_files(base_output_path)

    print(tiff_files)

    # List to hold open raster datasets
    src_files_to_mosaic = []
    
    # Open and append each raster dataset to the list
    for fp in tiff_files:
        src = rio.open(fp)
        src_files_to_mosaic.append(src)
    
    # Merge function returns a single mosaic array and the transformation info
    mosaic, out_trans = merge(src_files_to_mosaic)
    
    # Copy the metadata
    out_meta = src.meta.copy()
    
    # Update the metadata to reflect the number of layers
    out_meta.update({"driver": "GTiff",
                     "height": mosaic.shape[1],
                     "width": mosaic.shape[2],
                     "transform": out_trans,
                     "crs": src.crs})
    
    # Write the mosaic raster to disk
    with rio.open(merged_output_path, "w", **out_meta) as dest:
        dest.write(mosaic)

    # Close the opened files
    for src in src_files_to_mosaic:
        src.close()

    print(f"Merged TIFF saved to {merged_output_path}")

def find_clipped_tiff_files(base_output_path):
    search_criteria = f"/home/jon/.cache/elevation/SRTM1/{base_output_path}_*_clipped.tif"
    tiff_files = glob.glob(search_criteria)

    return tiff_files

def find_tiff_files(base_output_path):
    search_criteria = f"/home/jon/.cache/elevation/SRTM1/{base_output_path}_*.tif"
    tiff_files = glob.glob(search_criteria)

    return tiff_files

def clip_raster(input_tif, output_tif, bbox):
    """
    Clips a raster file to the specified bounding box.

    Parameters:
    - input_tif: Path to the input TIFF file.
    - output_tif: Path to the output TIFF file.
    - bbox: A tuple of (xmin, ymax, xmax, ymin) for the bounding box.
    """
    xmin, ymax, xmax, ymin = bbox
    ds = gdal.Translate(output_tif, input_tif, projWin=[xmin, ymax, xmax, ymin])
    ds = None  # Close the dataset

def calculate_bbox_rows_cols(bbox, tile_size_degree):
    """
    Calculate the number of rows and columns needed to cover the area defined by bbox.
    
    Parameters:
    - bbox: A tuple of (min_lon, min_lat, max_lon, max_lat)
    - tile_size_degree: The size of each tile in degrees (assuming square tiles)
    
    Returns:
    - A tuple of (rows, columns)
    """
    min_lon, min_lat, max_lon, max_lat = bbox
    lon_diff = max_lon - min_lon
    lat_diff = max_lat - min_lat
    
    cols = int(lon_diff / tile_size_degree) + 1
    rows = int(lat_diff / tile_size_degree) + 1
    
    return (rows, cols)

def save_boundary_svg(state_boundary, state_name):
    # Configure the plot to not display axis for a cleaner SVG
    fig, ax = plt.subplots(figsize=(10, 10))
    state_boundary.plot(ax=ax, color='none', edgecolor='black')
    ax.axis('off')

    # Save the plot as an SVG file
    svg_file_path = f"{state_name.lower()}_boundary.svg"
    plt.savefig(svg_file_path, format='svg', bbox_inches='tight')
    plt.close()

def save_shapefile(state_boundary, state_name):
    state_folder_name = state_name.lower()
    
    os.makedirs(state_folder_name, exist_ok=True)

    # Define the output path for the shapefile
    output_filename = f'./{state_folder_name}/{state_name.lower()}_boundary.shp'

    # Export the GeoDataFrame to a shapefile
    state_boundary.to_file(output_filename)

    return output_filename

def download_elevation_data(sub_boxes, base_output_path, shapefile_path):
    """
    Downloads elevation data for each section defined by sub_boxes and clips it to a shapefile.

    Parameters:
    - sub_boxes: List of bounding boxes for each section.
    - base_output_path: Base path for output files, which will have indexes appended.
    - shapefile_path: Path to the shapefile used for clipping the elevation data.
    """

    state_boundary_gdf = gpd.read_file(shapefile_path)

    for idx, bbox in enumerate(sub_boxes):
        output_file = f"{base_output_path}_{idx}.tif"
        actual_output_path = f'/home/jon/.cache/elevation/SRTM1/{output_file}'
        
        elevation.clip(bounds=bbox, output=output_file, product='SRTM1')

        with rio.open(actual_output_path) as src:
            # Clip the tile to the shapefile boundary
            out_image, out_transform = mask(src, state_boundary_gdf.geometry, crop=True)
            out_meta = src.meta.copy()
            
            # Update metadata for the clipped file
            out_meta.update({"driver": "GTiff",
                             "height": out_image.shape[1],
                             "width": out_image.shape[2],
                             "transform": out_transform})
                             
            # Save the clipped tile to a new file
            clipped_output_path = f"{actual_output_path.replace('.tif', '')}_clipped.tif"
            with rio.open(clipped_output_path, "w", **out_meta) as dest:
                dest.write(out_image)

        print(f"Clipped and downloaded {clipped_output_path}")
        
        # Optionally, display the clipped DEM
        with rio.open(clipped_output_path) as clipped_dem:
            show(clipped_dem, title=f"Clipped DEM {idx}")

        elevation.clean()  # Clean cache after each download

def split_bbox(bbox, rows, cols):
    """
    Splits the bounding box into smaller sections.

    Parameters:
    - bbox: Tuple of (min_lon, min_lat, max_lon, max_lat).
    - rows, cols: How many sections to split into vertically and horizontally.

    Returns:
    - List of tuples representing the smaller bounding boxes.
    """
    min_lon, min_lat, max_lon, max_lat = bbox
    lon_step = (max_lon - min_lon) / cols
    lat_step = (max_lat - min_lat) / rows

    sub_boxes = []
    for i in range(rows):
        for j in range(cols):
            sub_min_lon = min_lon + j * lon_step
            sub_max_lon = sub_min_lon + lon_step
            sub_min_lat = min_lat + i * lat_step
            sub_max_lat = sub_min_lat + lat_step
            sub_boxes.append((sub_min_lon, sub_min_lat, sub_max_lon, sub_max_lat))

    return sub_boxes

def validate_state_name(state_name):
    us_states = [
        "Alabama", "Alaska", "Arizona", "Arkansas", "California", 
        "Colorado", "Connecticut", "Delaware", "Florida", "Georgia", 
        "Hawaii", "Idaho", "Illinois", "Indiana", "Iowa", 
        "Kansas", "Kentucky", "Louisiana", "Maine", "Maryland", 
        "Massachusetts", "Michigan", "Minnesota", "Mississippi", "Missouri", 
        "Montana", "Nebraska", "Nevada", "New Hampshire", "New Jersey", 
        "New Mexico", "New York", "North Carolina", "North Dakota", "Ohio", 
        "Oklahoma", "Oregon", "Pennsylvania", "Rhode Island", "South Carolina", 
        "South Dakota", "Tennessee", "Texas", "Utah", "Vermont", 
        "Virginia", "Washington", "West Virginia", "Wisconsin", "Wyoming"
    ]

    return state_name in us_states

def clean_up_intermediate_files(state_name):
    tiff_files = find_tiff_files(f'{state_name.replace(" ", "_").lower()}_section_elevation')

    for file_path in tiff_files:
        if os.path.exists(file_path):
            os.remove(file_path)
